## [M-1] 悪意のあるトークンコントラクトが設定されていることでorderをロックする可能性がある脆弱性

### ■ カテゴリー

ERC20、ERC721

### ■ 条件

次のいずれかの変数に悪意あるトークンのアドレスが登録されていた場合に、`exercise()`か`withdraw()`をが呼びだされた場合

- baseAsset
- floorTokens[]
- erc20Assets[]
- erc721Assets[]

### ■ ハッキングの詳細

```sol
bool isLong;
address baseAsset;
```

```sol
address[] floorTokens;
ERC20Asset[] erc20Assets;
```

攻撃者は、注文を作成し、そのアドレスの1つを攻撃者のコントロール下にある悪意のあるコントラクトに設定することができる。攻撃者は、ユーザーが注文を出すのを許可し、その後、悪意のあるコントラクトの変数をトグルして、常にそれを元に戻すようにする。

攻撃者は、注文が好ましくないポジションにある場合（例えば、ショートして価格が上昇した場合）、注文が`exercise()`されるのを防ぐことによって利益を得る。攻撃者は、時間切れか価格が下がるのを待ち、悪意のあるトークンで転送が行われるようにする。

`withdraw()`関数も信頼できない外部アドレスを呼び出すため、同様の攻撃を行うことができます。この場合、攻撃者はオプションを行使し、他のユーザーがNFTまたはERC20トークンを要求できないようにすることができます。

### ■ 修正方法

ERC20かERC721を継承したトークンのみを登録するように承認制で登録するかホワイトリスト化すること。  

例えば次のようなメソッドを実装してowner権限を持つアドレスが承認したトークンの配列を用意するようにする。

```sol
function addApprovedTokens(address _token) private {
    if (msg.sender != owner) revert();
    erc20Assets.push(_token);
  }
```